---
title: JVM---内存区域
tags: java,jvm,内存区域
grammar_cjkRuby: true
---

* [程序计数器](#程序计数器)
* [Java虚拟机栈](#java虚拟机栈)
* [本地方法栈](#本地方法栈)
* [Java堆](#java堆)
* [方法区](#方法区)
* [运行时常量](#运行时常量)
* [直接内存](#直接内存)
* [总结](#总结)

![java虚拟器运行时数据区][1]
# 程序计数器

> 程序计数器可以视为当前线程所执行的字节码行号指示器。

> 每条线程都有独立的**计数器**，保证线程切换恢复正确位置，因此程序计数器这一块内存区域是线程隔离的。该区域是唯一一个没有规定任何OutOfMemoryError的区域。
> **线程私有**。

# Java虚拟机栈

> 虚拟机栈描述的是Java方法执行的内存模型：它内部由**栈帧构成**，一个栈帧代表一个调用的方法，线程在每次方法调用执行时创建一个栈帧然后压栈，栈帧用于存放**局部变量、操作数、动态链接、返回地址等信息**。方法执行完成后对应的栈帧出栈。我们平时说的栈内存就是指这个栈。

> 一个线程中的方法可能还会调用其他方法，这样就会构成方法调用链，而且这个链可能会很长，而且每个线程都有方法处于执行状态。对于执行引擎来说，只有活动线程栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），这个栈帧关联的方法称为当前方法（Current Method）。
> **线程私有**。

![虚拟机栈][2]

虚拟机栈的2种异常：

 - StackOverFlowError：调用链过长，线程请求深度大于JVM所允许的深度。
 - OutOfMemoryError：虚拟机栈动态扩展时无法申请到足够内存。



# 本地方法栈

> 本地方法栈与虚拟机栈的所用很相似，是虚拟机线程调用Native方法执行时的栈。Java可以通过java本地接口JNI（Java Native Interface）来调用其它语言编写（如C）的程序，在Java里面用native修饰符来描述一个方法是本地方法。

# Java堆

> Java堆是JVM管理的最大一块内存，是**线程共享**的，在JVM启动时创建。堆存放所有**对象实例以及数组**。

> 堆是java垃圾收集器管理的主要区域（所以很多时候会称它为GC堆）。从GC回收的角度看，由于现在GC基本都是采用的分代收集算法，所以堆内存结构还可以分块成：新生代和老年代、永久代；再细一点的有Eden空间、From Survivor空间、To Survivor空间等。值得注意的是，从JKD1.7开始，永久代Perm逐渐被移除，最新的JDK1.8中已经使用元空间（MetaSpace）代替永久代。
>如果堆中没有内存完成实例分配并且无法扩展，将会抛出OutOfMemoryError异常。

# 方法区
> Java虚拟机规范将方法区描述为堆的逻辑部分，但是却称为非堆（Non-Heap），在Sun的HotSpot虚拟机中，可以将方法区理解为堆内存块中的永久代（Permanent Generation）。它是**线程共享**的。

> 方法去用于存储在加载类文件时，用于存放**加载过的类信息，常量，静态变量，及JIT编译后的代码（类方法）等数据**。

# 运行时常量

> 常量池（Constant Pool Table），用于存放**编译期生成的各种字面量、符号引用，文字字符串、final变量值、类名和方法名常量**，这部分内容将在类加载后存放到方法区的运行时常量池中。它们以数组形式访问，是调用方法、与类联系及类的对象化的桥梁。

> **运行时常量池除了存放编译期产生的Class文件的常量外，还可存放在程序运行期间生成的新常量**，比较常见增加新常量方法有String类的internd()方法。String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。不过JDK7的intern（）方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用。

> 但是，**JDK1.7之前运行时常量池是方法区的一部分**，JDK1.7及之后版本已经将运行时常量池从方法区中移了出来，在堆（Heap）中开辟了一块区域存放运行时常量池。

# 直接内存

> 直接内存（Direct memory）并不是JVM运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁使用，而且它也可能导致OutOfMemoryError异常出现。

# 总结

 - 在程序运行时类是在方法区，实例对象本身在堆里面。
 - 方法字节码在方法区。
 - 线程调用方法执行时创建栈帧并压栈，方法的参数和局部变量在栈帧的局部变量表。
 - 对象的实例变量和对象一起在堆里，所以各个线程都可以共享访问对象的实例变量。
 - 静态变量在方法区，所有对象共享。字符串常量等常量在运行时常量池。
 - 各线程调用的方法，通过堆内的对象，方法区的静态数据，可以共享交互信息。

  [1]: ./images/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.PNG "jvm-运行时数据区域"
  [2]: ./images/jvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.jpg "jvm-虚拟机栈"