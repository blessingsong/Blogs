---
title: JVM---内存模型与线程
tags: volatile
grammar_cjkRuby: true
---
# Java内存模型
Java内存模型用来屏蔽各种硬件和操作系统的内存访问差异，以实现在各种平台下都能达到一致的内存访问效果。
# 主内存与工作内存
线程、主内存、工作内存三者的交互关系如下：

![enter description here][1]
## 内存间交互操作
Java内存模型定义了八种操作：

 - lock（锁定）：作用于主内存的变量，它把一个变量标识为一个线程独占的状态；
 - unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
 - read（读取）：作用于主内存的变量，它把一个变量的值从主内存传送到线程中的工作内存，以便随后的load动作使用；
 - load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中；
 - use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎；
 - assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量；
 - store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作；
 - write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值写入主内存的变量中。

# 对于volatile型变量的特殊规则
关键字volatile是JVM提供最轻量级的同步机制。
当一个变量被定义成volatile后，它具有两个特性：

 - 第一，volatile变量对所有线程是立即可见的，对于volatile变量所有的写操作都能立刻反应到其他线程之中；但volatile变量只能保证可见性，不能保证在并发下是安全的。
 - 第二，禁止指令重排序优化。

# 原子性、 可见性与有序性
Java内存模型是围绕着在并发过程中如何处理原子性、 可见性和有序性这3个特征来建立的， 

 - 原子性：由Java内存模型来直接保证的原子性变量操作包括read、 load、assign、 use、
   store和write，基本数据类型的访问读写是具备原子性的，如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，synchronized关键字就隐式的使用这两个操作，因此在synchronized块之间的操作也具备原子性。
 - 可见性：指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。普通变量和volatile变量都通 
   过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，不同点在于，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
   Synchronized和final也实现了可见性，前者是因为对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，后者则是由于被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值。
 - 有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。
   前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
#  先行发生原则
先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、 发送了消息、 调用了方法等。 

Java内存模型存在一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。 

 1. 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行生于书写在后面的操作。 
 2. 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。 这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。 
 3. volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。 
 4. 线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。 
 5. 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、 Thread.isAlive（）的返回值等手段检测到线程已经终止执行。 
 6. 线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。 
 7. 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于其finalize（）方法的开始。 
 8. 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 

时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。


  [1]: ./images/jvm-%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png "jvm-主内存工作内存"